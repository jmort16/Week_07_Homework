WEEK 7 HOMEWORK

#1  Create a new column called “status” in the rental table that uses a case statement to indicate if a film was returned late, early, or on time. 

ALTER TABLE rental
ADD status VARCHAR(8);
SELECT *
FROM film
	LEFT JOIN inventory AS inv
		ON film.film_id = inv.film_id
	LEFT JOIN rental AS r
		ON inv.inventory_id=r.inventory_id
UPDATE rental SET status =  WHERE ;
UPDATE rental SET status = 'Early' WHERE ;
UPDATE rental SET status = 'On Time' WHERE (EXTRACT (DAY FROM rental.return_date - rental.rental_date)) = film.rental_duration;
SELECT
	film.title,
	r.status
FROM film
	LEFT JOIN inventory AS inv
		ON f.film_id = inv.film_id
	LEFT JOIN rental AS r
		ON inv.inventory_id=r.inventory_id
		
--Mangai's suggestion:
UPDATE rental
SET status =
    CASE WHEN (EXTRACT (DAY FROM rental.return_date - rental.rental_date)) > film.rental_duration THEN 'Late'
		WHEN (EXTRACT (DAY FROM rental.return_date - rental.rental_date)) < film.rental_duration THEN 'Early'
		ELSE 'On Time'
FROM film


/*  





#2  Show the total payment amounts for people who live in Kansas City or Saint Louis.

SELECT 
	cust.last_name,
	cust.first_name,
	city.city,
	SUM(pmt.amount) AS total_payments
FROM city
LEFT JOIN address
ON city.city_id = address.city_id
LEFT JOIN customer AS cust
ON address.address_id=cust.address_id
LEFT JOIN payment as pmt
ON cust.customer_id = pmt.customer_id
WHERE city.city = 'Kansas City' OR city.city = 'Saint Louis'
GROUP BY city.city, cust.last_name, cust.first_name

/* First, I mapped out a plan on paper to connect the city name with the payment amount, which is my ultimate goal
(by way of customer, of course).  I started with city, left joined that to address by city_id, then to customer by 
address_id, then to payment by customer_id.  I used the aggregate SUM to find the total payments by customer, and
included that in my SELECT statement at the start.  According to my table, there is only one customer from Saint
Louis and one from Kansas City...which seems strange, to be honest.  But I did some further filtering through the
data and this seems to be accurate. */

#3  How many films are in each category? Why do you think there is a table for category and a table for film category?

SELECT 
	cat.name as category,
	COUNT(fc.film_id) AS number_of_films
FROM category AS cat
LEFT JOIN film_category AS fc
ON cat.category_id = fc.category_id
GROUP BY category
ORDER BY category;

/*  I only needed to join two tables this time, so that was nice!  :)  I wanted to display the category name, but 'name'
was too vague, so I aliased it as 'category'.  I used the aggregate COUNT to find the number of film_id's by category.
Of course, I had to join the category and film_category tables in order to accomplish that.*/

/* As to why there is a table for category and another table for film_category, I think that the category table serves the purpose of assigning an ID number to each new category, whereas the film_category table serves to assign each film (via its ID) to the appropriate category. */

#4  Show a roster for the staff that includes their email, address, city, and country (not ids)

SELECT
	s.last_name,
	s.first_name,
	s.email,
	address.address,
	city.city, 
	country.country
FROM staff AS s
	LEFT JOIN address
	ON s.address_id = address.address_id
	LEFT JOIN city
	ON address.city_id = city.city_id
	LEFT JOIN country
	ON city.country_id=country.country_id

/*  This query was just a matter of locating the tables containing each of the fields I needed to include in my SELECT
statement, then joining all of the tables necessary to gather the information into one table.  I used the ID for the
purpose of joining, but none were listed in my SELECT statement, which means that they won't appear in my result. */

#5  Show the film_id, title, and length for the movies that were returned from May 15 to 31, 2005

SELECT 
	f.film_id,
	f.title,
	f.length as length_in_minutes,
	r.return_date
FROM film as f
LEFT JOIN inventory AS inv
ON f.film_id=inv.film_id
LEFT JOIN rental AS r
ON inv.inventory_id=r.inventory_id
WHERE (r.return_date >= '2005-05-15' AND r.return_date <= '2005-05-31')
ORDER BY r.return_date

/*  I started with the film table, since it contains the information to be displayed in my result.  I had to join the
film table to the rental table, however, so that I could filter the films by return date.  I had to use the inventory
table to connect my joins between the film and rental tables.  Finally, I ordered by rental date just to verify the
efficacy of my query. */


#6  Write a subquery to show which movies are rented below the average price for all movies. 

SELECT 
	title
FROM film
WHERE rental_rate < (SELECT 
	 			AVG(rental_rate)
	 			FROM film)

/* I selected the title and rental_rate columns from the film table, then wrote a subquery that would find the average
rental rate for the films.  I used my subquery in the WHERE clause to compare each film's rental rate with the average,
and displayed only those films with a lower than average rental rate. */


#7  Write a join statement to show which movies are rented below the average price for all movies.

SELECT 
	title,
	rental_rate,
	AVG(rental_rate) AS avg_rental_rate
FROM 
	film
WHERE rental_rate < avg_rental_rate

#8  Perform an explain plan on 6 and 7, and describe what you’re seeing and important ways they differ.

	For question 6:
	"Seq Scan on film  (cost=66.51..133.01 rows=333 width=21)"
	"  Filter: (rental_rate < $0)"
	"  InitPlan 1 (returns $0)"
	"    ->  Aggregate  (cost=66.50..66.51 rows=1 width=32)"
	"          ->  Seq Scan on film film_1  (cost=0.00..64.00 rows=1000 width=6)"


#9  With a window function, write a query that shows the film, its duration, and what percentile the duration fits into. This may help https://mode.com/sql-tutorial/sql-window-functions/#rank-and-dense_rank 

SELECT
	film.title,
	film.length,
	NTILE(100) OVER
         (ORDER BY film.length)
         AS percentile
FROM film
ORDER BY percentile DESC;


#10  In under 100 words, explain what the difference is between set-based and procedural programming. Be sure to specify which sql and python are. 
